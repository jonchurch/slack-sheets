// here we are importing the API client for the service
// This can either be homegrown, or a dep, or a combo
const slack = require('slack')

/* 
 * A Service represents the code needed to publish triggers, and respond to actions
 * It encapsulates the API for the service, and action creation/publishing
 * It needs some kind of service discovery, no? Or some way to let the system overall know what services are configured
 * That sounds sorta, uhh, vague? But it will be important for a frontend, where we would need to have a list of all available Services, their triggers, their actions, and the payload format for each
 *
 *
 * NEXT STEPS:
 *   - add more slack events
 *   - add slack auth setup?
 *
 */

const serviceName = 'slack'

module.exports = function({router, subscribe, publish}) {
	// setup webhook route w/ express server
	router.route(`/${serviceName}`).post((req, res) => {
		// slack requires a handshake challenge to verify webhooks during setup
    const { challenge } = req.body
    if (challenge) {
      res.send(challenge)
    } else {
      // console.log(req.body)
      res.sendStatus(200)
      handleSlackEvent(req.body)
    }
		})
	
	router.route(`/${serviceName}/test`).get((req, res) => res.send('ok'))

	// slack service specific webhook event handler
	// formats and publishes triggerEvents
  function handleSlackEvent(webhookPayload) {
    // console.log({payload})
    const { event, team_id } = webhookPayload
	  if (event.bot_id) {
		  // ignore events generated by bots
		  // (could look for our own bot id to ignore only our bot's actions)
      return
    }

	  // Format the webhook event into standard trigger event
	  // this incorrectly assumes ALL webhook events are going to be messagePosted
	  // Thus, this is still pseudocode
    const triggerEvent = {
      // eventType: "trigger",
      service: 'slack',
      triggerType: 'messagePosted',
      payload: {
        team: team_id,
        user: event.user,
        // type: "message",
        text: event.text,
        channel: event.channel,
      },
    }
	  // Probably need to rethink this triggerChannel stuff. I'm not too into how we're doing things now
	  // But it doesn't matter currently, and isn't too tough to change later on
    const triggerChannel = `${triggerEvent.service}/${triggerEvent.triggerType}`
    console.log({ triggerEvent })
    publish('trigger.', { triggerChannel, triggerEvent })
  }

	// i don't think action fulfillment logic needs to be exposed outside the service.
	// But it needs to get organized in here somehow
  const actions = {
    postMessage: action => {
      // console.log({action})
      // use slack API to send the message w/ the data provided by the recipe?
      const { text } = action.payload
      slack.chat.postMessage({
        token: process.env.SLACK_TOKEN,
        channel: '#general',
        text,
      })
    },
  }
	// const serviceName = 'slack'
	// this prolly should be sync, no? or otherwise block execution until these are setup?
	// I can think through that later, but this works, or a variation of it
	Object.keys(actions)
		.forEach(method=> {
		subscribe(`${serviceName}/${method}`, event => actions[method](event))
		})
	// oooh, I can do an Object.keys on this here action object above, and register all these listeners AUTOMAGICALLY!
  // subscribe('slack/postMessage', action => actions.postMessage(action))
}
